# the_goods

```elixir
Mix.install([
  {:kino, "~> 0.7.0"}
])
```

## day 1

```elixir
input = Kino.Input.textarea("Name")
```

```elixir
name = Kino.Input.read(input)
```

### part 1

<!-- livebook:{"break_markdown":true} -->

##### sample input

```elixir
sample_data_day_1 = "1000
2000
3000

4000

5000
6000

7000
8000
9000

10000"
```

```elixir
{:ok, day_one_input} = File.read("inputs/day_1.txt")
day_one_input
```

```elixir
defmodule Advent do
  def split_to_int(list) do
    list
    |> Enum.map(fn amount -> String.replace(amount, "\n", ",") end)
    |> Enum.map(fn amount -> String.split(amount, ",") end)
    |> Enum.concat()
    |> Enum.map(fn amount -> String.to_integer(amount) end)
  end
end
```

new clean way

```elixir
day_one =
  String.split(sample_data_day_1, "\n\n")
  |> Enum.map(fn x -> String.split(x, ",") end)
  |> Enum.map(fn elf_amount -> Advent.split_to_int(elf_amount) end)
  |> Enum.map(fn elf_amount -> Enum.reduce(elf_amount, fn amount, acc -> amount + acc end) end)
```

```elixir
Enum.max(day_one)
```

old UGLY way

```elixir
data = String.split(day_one_input, "\n\n")
data = Enum.map(data, fn x -> [x] end)
data = Enum.map(data, fn x -> Enum.map(x, fn y -> String.replace(y, "\n", ",") end) end)
data = Enum.map(data, fn x -> Enum.map(x, fn y -> String.split(y, ",") end) end)
data = Enum.concat(data)
data = Enum.map(data, fn x -> Enum.map(x, fn y -> String.to_integer(y) end) end)
data = Enum.map(data, fn x -> Enum.reduce(x, fn y, acc -> y + acc end) end)
data = Enum.sort(data)
List.last(data)
```

### part two

```elixir
day_one
|> Enum.sort()
|> Enum.take(-3)
|> Enum.sum()
```

## day 2

```elixir
input = Kino.Input.textarea("Paste input here:")
```

```elixir
day_two_input = Kino.Input.textarea("Day two input:")
```

A : X = 3
A : Y = 6
A : Z = 0
B : X = 0
B : Y = 3
B : Z = 6
C : X = 6
C : Y = 0
C : Z = 3

A = Rock
B = Paper
C = Scissors

X = Rock
Y = Paper 
Z = Scissors

```elixir
defmodule Two do
  def score(scores) do
    case scores do
      ["A X"] -> 3 + 1
      ["A Y"] -> 6 + 2
      ["A Z"] -> 0 + 3
      ["B X"] -> 0 + 1
      ["B Y"] -> 3 + 2
      ["B Z"] -> 6 + 3
      ["C X"] -> 6 + 1
      ["C Y"] -> 0 + 2
      ["C Z"] -> 3 + 3
    end
  end

  # rock = 1 A
  # paper =2 B
  # scissors =3 C

  def part_two([tool, "X"]) do
    case tool do
      "A" -> 3
      "B" -> 1
      "C" -> 2
    end
  end

  def part_two([tool, "Y"]) do
    case tool do
      "A" -> 1 + 3
      "B" -> 2 + 3
      "C" -> 3 + 3
    end
  end

  def part_two([tool, "Z"]) do
    case tool do
      "A" -> 2 + 6
      "B" -> 3 + 6
      "C" -> 1 + 6
    end
  end
end
```

```elixir
day_two_sample = Kino.Input.read(input)
```

```elixir
day_two = Kino.Input.read(day_two_input)
```

```elixir
String.split(day_two_sample, "\n", trim: true)
|> Enum.chunk_every(1)
|> Enum.reduce(0, fn x, acc -> Two.score(x) + acc end)
```

### part two

```elixir
String.split(day_two, "\n", trim: true)
|> Enum.chunk_every(1)
|> Enum.map(fn scores ->
  Enum.map(scores, fn score -> String.split(score, " ") end)
  |> Enum.concat()
end)
|> Enum.reduce(0, fn x, acc -> Two.part_two(x) + acc end)
```

## day 3

### part 1

```elixir
three_sample_input = Kino.Input.textarea("Paste input here:")
```

```elixir
day_three_sample = Kino.Input.read(three_sample_input)
```

```elixir
lower = for n <- ?a..?z, do: <<n::integer>>
lower
# upper = for n <- ?A..?Z, do: << n :: binary >>
```

```elixir

```

```elixir
defmodule Three do
  def break_down(rucksack) do
    Enum.map(rucksack, fn x -> String.graphemes(x) end)
  end
end
```

```elixir
String.split(day_three_sample)
|> Enum.chunk_every(1)
|> Enum.map(fn x -> Three.break_down(x) end)
|> Enum.concat()
|> Enum.map(fn x -> Enum.chunk_every(x, trunc(length(x) / 2)) end)
```

```elixir
trunc(String.length("jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL") / 2)
```
